#!/usr/bin/env bash
# Wrap `screen` to enable the command-line as IDE.
#
# SCREENRC configures the filename of GNU screen's rc configuration file.
# SCREENRC_DEFAULT configures the filepath of the default .screenrc to use.
#
# Look for a project-local .screenrc file, first checking for a local
# .screenrc-username file to allow personal customizations.
#
# By convention, a project-local .screenrc sources $HOME/.screenrc.
# When there's no project-local .screenrc, use $SCREENRC_DEFAULT.
#
# See: ~/.screenrc-default

SCREEN=

SCREENRC="${SCREENRC:-.screenrc}"
SCREENRC_DEFAULT="${SCREENRC_DEFAULT:-$HOME/$SCREENRC}"

screen_running() {
    "$SCREEN" -ls | grep -q "\.$1\s";
}

main() {
    DIR="$( cd -P "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
    . "$DIR"/wrapper.bash

    SCREEN="$(set_aside_this_and_find_that "$DIR" screen)"

    if [ -z "$SCREEN" ]; then
        # No other `screen` found.
        # Expect set-aside function to write a not-found message to stderr.
        return 2
    fi

    # Build an array of options & arguments to inject into screen command call.
    declare -a arg

    # If no arguments are given, set a default sessionname.
    if [ $# -eq 0 ]; then
        # Use basename of $PWD as sessionname, e.g. ~/somedir is somedir.
        sessionname="${PWD##*/}"

        # Re-attach to screen if already running.
        if screen_running "$sessionname"; then
            exec "$SCREEN" -x "$sessionname"
        fi

        arg+=( -S "$sessionname" )
    fi

    # Select a screenrc, in order of priority (see comment at top of file).
    if [ -e "${SCREENRC}-${USER}" ]; then
        arg+=( -c "$SCREENRC-${USER}" )
    elif [ -e "$SCREENRC" ]; then
        arg+=( -c "$SCREENRC" )
    elif [ -e "$SCREENRC_DEFAULT" ]; then
        arg+=( -c "$SCREENRC_DEFAULT" )
    fi

    exec "$SCREEN" "${arg[@]}" "$@"
}

main "$@"
