#!/bin/bash
# Wrap GNU screen. Extend screen to:
#
# * prefer .screenrc-$USER or .screenrc in $PWD before $HOME/.screenrc.
# * default the sessionname to the basename of $PWD.

# Override these with eponymous environment variables.
SCREENRC="${SCREENRC:-.screenrc}" # conventional name of screenrc
SCREENRC_DEFAULT="${SCREENRC_DEFAULT:-$HOME/$SCREENRC}" # project default

DIR="$( cd -P "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
. "$DIR"/wrapper.bash

screen="$(set_aside_this_and_find_that "$DIR" screen)"

if [ -z "$screen" ]; then
    # No other `screen` found. Present a command not found.
    PATH= screen
    return 2
fi

# SCREENRC and SCREENRC_DEFAULT variables:
#
# SCREENRC is configuring what GNU screen calls it's rc file.
#
# Below, you'll see that this wrapper looks for a project-local .screenrc which
# is expected to source $HOME/.screenrc. If no local .screenrc is found, use
# $SCREENRC_DEFAULT, which is $HOME/.screenrc, unless you set the
# SCREENRC_DEFAULT env variable to some rc file which provides a nice set of
# windows which you'd like to have on each project.
#
# See ~/.screenrc-default in the repository containing this wrapper.

# Build a string of options & arguments to inject into screen command call.
local_args=""

# If no arguments are given, set a default sessionname.
if [ $# -eq 0 ]; then
    # Set sessionname to basename of $PWD, e.g. ~/someproject is someproject.
    local_args="$local_args -S ${PWD##*/}"
fi

# Select a screenrc, in order of priority (see comment at top of file).
if [ -e "${SCREENRC}-${USER}" ]; then
    exec "$screen" -c "$SCREENRC-${USER}" $local_args $@
elif [ -e "$SCREENRC" ]; then
    exec "$screen" -c "$SCREENRC" $local_args $@
elif [ -e "$SCREENRC_DEFAULT" ]; then
    exec "$screen" -c "$SCREENRC_DEFAULT" $local_args $@
else
    exec "$screen" $local_args $@
fi
