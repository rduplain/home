#!/usr/bin/env bash
# Wrap `screen` to enable the command line as IDE.
#
# SCREENRC configures the filename of GNU screen's rc configuration file.
# SCREENRC_DEFAULT configures the filepath of the default .screenrc to use.
#
# Look for a project-local .screenrc file, in order:
#
# 1. A local .screenrc-username file, to allow personalization.
# 2. A local .screenrc file, typically checked in with a project.
# 3. The file at $SCREENRC_DEFAULT, as a fallback.
#
# By convention, a project-local .screenrc sources $HOME/.screenrc.
#
# See: ~/.screenrc-default

SCREEN=

SCREENRC="${SCREENRC:-.screenrc}"
SCREENRC_DEFAULT="${SCREENRC_DEFAULT:-$HOME/$SCREENRC}"

project_directory() {
    # Print session directory to stdout, assuming the session names a project.

    sessionname="$1"
    shift

    if [ -d "$HOME/src/$sessionname" ]; then
        echo "$HOME/src/$sessionname"
        return
    fi

    # Support grouped/nested projects when directory contains shell init files.
    for dir in "$HOME"/src/*/"$sessionname"; do
        up="$(dirname "$dir")"

        if [ -e "$up"/.bashrc ] || [ -e "$up"/.env ]; then
            echo "$dir"
            return
        fi
    done

    echo "$HOME/src/$sessionname"
}

screen_running() {
    # Check whether a screen session is running with given name.
    #
    # Note: This function uses the global SCREEN variable set in `main`.

    if [ -z "$@" ]; then
        return 2
    fi

    "$SCREEN" -ls | grep -q "\.$1\s";
}

sessionname() {
    # Print session name for screen to stdout, based on arguments.
    #
    # Print nothing, if default does not apply and no session name is found.

    if [ -n "$(sessionname_attach "$@")" ]; then
        sessionname_attach "$@"
    elif [ -n "$(sessionname_start "$@")" ]; then
        sessionname_start "$@"
    elif [ $# -eq 0 ]; then
        sessionname_default
    fi
}

sessionname_attach() {
    # Print session name for screen attach to stdout, if found in arguments.

    while getopts ":r:x:" opt; do
        case $opt in
            r|x)
                echo "$OPTARG"
                break
                ;;
        esac
    done
}

sessionname_default() {
    # Print default session name for new screen to stdout.
    #
    # Use basename of $PWD as sessionname, e.g. ~/src/project is "project".

    echo "${PWD##*/}"
}

sessionname_start() {
    # Print session name for new screen to stdout, if found in arguments.

    while getopts ":S:" opt; do
        case $opt in
            S)
                echo "$OPTARG"
                break
                ;;
        esac
    done
}

main() {
    # Start & attach sessions automatically.

    DIR="$( cd -P "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
    . "$DIR"/wrapper.bash

    SCREEN="$(set_aside_this_and_find_that "$DIR" screen)"

    if [ -z "$SCREEN" ]; then
        # No other `screen` found.
        # Expect set-aside function to write a not-found message to stderr.
        return 2
    fi

    sessionname="$(sessionname "$@")"

    # Re-attach to screen if already running.
    if screen_running "$sessionname"; then
        exec "$SCREEN" -x "$sessionname"
    fi

    # Screen is not running. If request to attach, start screen automatically.
    if [ -n "$(sessionname_attach "$@")" ]; then
        project="$(project_directory "$sessionname")"
        if [ ! -d "$project" ]; then
            echo "There is no screen to be resumed matching $sessionname." >&2
            return 1
        fi
        # Start screen in background.
        cd "$project"; screen -fn -dmS "$sessionname"
        # Wait for screen.
        while ! screen -ls "$sessionname"  > /dev/null 2>&1; do
            sleep 0.05
        done
        # Attach to new screen.
        exec "$SCREEN" -x "$sessionname"
    fi

    # Build an array of options & arguments to inject into screen command call.
    declare -a arg

    # Set session name if not provided in arguments.
    if [ -n "$sessionname" ] && [ -z "$(sessionname_start "$@")" ]; then
        arg+=( -S "$sessionname" )
    fi

    # Select a screenrc, in order of priority (see comment at top of file).
    if [ -e "${SCREENRC}-${USER}" ]; then
        arg+=( -c "$SCREENRC-${USER}" )
    elif [ -e "$SCREENRC" ]; then
        arg+=( -c "$SCREENRC" )
    elif [ -e "$SCREENRC_DEFAULT" ]; then
        arg+=( -c "$SCREENRC_DEFAULT" )
    fi

    # Pick up relative environment configuration before calling screen.
    if command -v source_these > /dev/null 2>&1; then
        walk_root_to_curdir omit_home source_these .bashrc .env #dir
    fi

    exec "$SCREEN" "${arg[@]}" "$@"
}

main "$@"
