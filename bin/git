#!/usr/bin/env bash
# Wrap `git` to use .homegit.

TIGLIKE=${TIGLIKE:-"%C(blue)%ad %C(green)%<(19)%an%C(auto)%h%d %C(reset)%s"}
TIGLIKE_DATE_FORMAT=${TIGLIKE_DATE_FORMAT:-"%Y-%m-%d %H:%M"}

declare -a arg
declare git

use_homegit() {
    [ -n "$USE_HOMEGIT" ] || \
        ( [ -d .homegit ] && ! [ -d .git ] ) || \
        [ "$PWD" = "$HOME/bin" ]
}

git_back_to() {
    local b target tmp

    if [ $# -ne 1 ]; then
        echo "usage: git back-to BRANCH" >&2
        return 2
    fi

    target="$1"
    shift

    if ! prompt_yn "Delete all local branches & re-checkout $target?"; then
        return 1
    fi

    echo 'Proceeding. Take a look at `git reflog` in case of problems.' >&2
    echo

    set -e

    tmp="git-back-to-$(date +%s)"
    "$git" "${arg[@]}" checkout -b "$tmp" >/dev/null 2>&1

    for b in $("$git" "${arg[@]}" for-each-ref refs/heads | cut -d/ -f3-); do
        if [ "$b" = "$tmp" ]; then
            continue
        fi

        "$git" "${arg[@]}" branch -D "$b"
    done

    echo

    "$git" "${arg[@]}" checkout "$target"
    "$git" "${arg[@]}" branch -D "$tmp" >/dev/null 2>&1
}

git_nameit() {
    echo -n "${GIT_NAMEIT_PREFIX:-$GIT_PUSHIT_PREFIX}"
    "$git" "${arg[@]}" log --pretty=format:%s -n 1 |\
        head -1 |\
        tr '[:upper:]' '[:lower:]' |\
        sed -e 's/[ _]/-/g' |\
        sed -e 's/[^A-Za-z0-9_-]//g'
    echo
}

git_pushit() {
    local current remote
    remote="${GIT_PUSHIT_REMOTE:-origin}"

    current=$("$git" "${arg[@]}" symbolic-ref HEAD 2>/dev/null | cut -d/ -f3-)
    if [ -z "$current" ]; then
        echo "error: not on any branch." >&2
        return 1
    fi

    export GIT_NAMEIT_PREFIX="${GIT_PUSHIT_PREFIX:-$GIT_NAMEIT_PREFIX}"
    "$git" "${arg[@]}" push "$remote" "$current":"$(git_nameit)"
}

git_set_url() {
    # Assume running from within project root.
    url=git@github.com:$(id -un)/${PWD##*/}.git
    echo "Setting remote origin to $(id -un)'s GitHub ..."
    "$git" "${arg[@]}" remote set-url origin "$url"
    "$git" "${arg[@]}" remote get-url origin
}

git_sync() {
    upstream=$(
        "$git" "${arg[@]}" \
               for-each-ref --format='%(upstream:short)' \
               "$("$git" "${arg[@]}" symbolic-ref -q HEAD)" 2>/dev/null)

    if [ -z "$upstream" ]; then
        echo "fatal: no tracking branch to sync" >&2
        return 2
    fi

    "$git" "${arg[@]}" fetch &&
        "$git" "${arg[@]}" rebase \
            --committer-date-is-author-date "$upstream"
}

git_tiglike() {
    exec env PAGER="less -S" "$git" "${arg[@]}" log \
         --pretty=format:"$TIGLIKE" \
         --date=format:"$TIGLIKE_DATE_FORMAT" \
         -- "$@"
}

main() {
    DIR="$( cd -P "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
    . "$DIR"/wrapper.bash

    if requested_only _source "$@"; then
        # Make `. git _source` available to pull in functions.
        return 0
    fi

    git="$(set_aside_this_and_find_that "$DIR" git)"

    if [ -z "$git" ]; then
        # No other `git` found.
        # Expect set-aside function to write a not-found message to stderr.
        return 2
    fi

    declare -a arg

    if use_homegit && ! requested clone "$@"; then
        arg=( --git-dir="$HOME"/.homegit --work-tree="$HOME" )
    else
        arg=( )
    fi

    if requested back-to "$1"; then
        shift
        git_back_to "$@"
    elif requested_only nameit "$@"; then
        git_nameit "$@"
    elif requested_only pushit "$@"; then
        git_pushit "$@"
    elif requested_only set-url "$@"; then
        git_set_url "$@"
    elif requested_only sync "$@"; then
        git_sync "$@"
    elif requested tiglike "$1"; then
        shift
        git_tiglike "$@"
    else
        exec "$git" "${arg[@]}" "$@"
    fi
}

main "$@"
