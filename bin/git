#!/usr/bin/env bash
# Wrap `git` to use .homegit.

TIGLIKE=${TIGLIKE:-"%C(blue)%ad %C(green)%<(19)%an%C(auto)%h%d %C(reset)%s"}
TIGLIKE_DATE_FORMAT=${TIGLIKE_DATE_FORMAT:-"%Y-%m-%d %H:%M"}

use_homegit() {
    [ -n "$USE_HOMEGIT" ] || \
        ( [ -d .homegit ] && ! [ -d .git ] ) || \
        [ "$PWD" = "$HOME/bin" ]
}

main() {
    DIR="$( cd -P "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
    . "$DIR"/wrapper.bash

    if requested_only _source "$@"; then
        # Make `. git _source` available to pull in functions.
        return 0
    fi

    git="$(set_aside_this_and_find_that "$DIR" git)"

    if [ -z "$git" ]; then
        # No other `git` found.
        # Expect set-aside function to write a not-found message to stderr.
        return 2
    fi

    declare -a arg

    if use_homegit && ! requested clone "$@"; then
        arg=( --git-dir="$HOME"/.homegit --work-tree="$HOME" )
    else
        arg=( )
    fi

    if requested_only sync "$@"; then
        upstream=$(
            "$git" "${arg[@]}" \
                   for-each-ref --format='%(upstream:short)' \
                   "$("$git" "${arg[@]}" symbolic-ref -q HEAD)" 2>/dev/null)

        if [ -z "$upstream" ]; then
            echo "fatal: no tracking branch to sync" >&2
            return 2
        fi

        "$git" "${arg[@]}" fetch &&
            "$git" "${arg[@]}" rebase \
                --committer-date-is-author-date "$upstream"
    elif requested_only tiglike "$@"; then
        exec env PAGER="less -S" "$git" "${arg[@]}" log \
             --pretty=format:"$TIGLIKE" \
             --date=format:"$TIGLIKE_DATE_FORMAT"
    else
        exec "$git" "${arg[@]}" "$@"
    fi
}

main "$@"
